<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Michał Wyrwa's Homepage">
  <meta name="author" content="Michał Wyrwa">
  
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@">
    <meta name="twitter:creator" content="@">
    <meta name="twitter:title" content="[OLD] Java 101: Enum &#43; Servlets">
    <meta name="twitter:description" content="[This is a post from my old website. Outdated packages and libraries. Viewer discretion is advised ;-)]
ENUM Typ enum, dodany w wersji 1.5, służy do definiowania stałych. Kiedy mamy z nim do czynienia, to wiemy że mamy do wyboru ograniczony zbiór możliwych opcji. Przykładowo, definiując enum poraRoku z góry wiemy, że będzie on przyjmować wartości jedynie spośród ZIMA, WIOSNA, LATO i JESIEN.
Każdy enum domyślnie rozszerza klasę java.lang.Enum, dlatego nie może rozszerzać żadnej innej klasy.">

    <meta property="og:url" content="/blog/2017-07-06-enumsql/" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content="[OLD] Java 101: Enum &#43; Servlets" />
    <meta property="og:description" content="[This is a post from my old website. Outdated packages and libraries. Viewer discretion is advised ;-)]
ENUM Typ enum, dodany w wersji 1.5, służy do definiowania stałych. Kiedy mamy z nim do czynienia, to wiemy że mamy do wyboru ograniczony zbiór możliwych opcji. Przykładowo, definiując enum poraRoku z góry wiemy, że będzie on przyjmować wartości jedynie spośród ZIMA, WIOSNA, LATO i JESIEN.
Każdy enum domyślnie rozszerza klasę java.lang.Enum, dlatego nie może rozszerzać żadnej innej klasy." />


  <title>[OLD] Java 101: Enum &#43; Servlets | Michał Wyrwa</title>

  <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <script src="https://kit.fontawesome.com/923575d7ad.js" crossorigin="anonymous"></script>
  <script defer src="/js/all.min.js"></script>
  
  <link href="/css/prism.css" rel="stylesheet" />
  <link rel="stylesheet" href="/css/academicons.min.css" />
  <link href="/css/scarabisterre.css" rel="stylesheet">
  
  
  

</head>

<body>

  <nav class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-navbar-collapse-1">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://miwy.github.io">Michał Wyrwa</a>
    </div>
    
    <div class="collapse navbar-collapse" id="bs-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li>
          <a href="/publications/">
            <i class="fa far fa-copy"></i>&nbsp;
            RESEARCH
          </a>
        </li>
        <li>
          <a href="/blog/">
            <i class="fa fas fa-quote-right"></i>&nbsp;
            BLOG
          </a>
        </li>
        <li>
          <a href="/teaching/">
            <i class="fa fas fa-user-graduate"></i>&nbsp;
            TEACHING
          </a>
        </li>
      </ul>
    </div>
  </div>
</nav>

  
  <div class="container">

    
    <div class="row">
      <div class="col-md-8 col-md-offset-2">

        <h2>[OLD] Java 101: Enum &#43; Servlets</h1>
        <p>
          <em>Thu, Jul 6, 2017</em>
        </p>
        <p>
          

<p>[This is a post from my old website. Outdated packages and libraries. Viewer discretion is advised ;-)]</p>

<h2 id="enum">ENUM</h2>

<p>Typ <strong>enum</strong>, dodany w wersji 1.5, służy do definiowania stałych. Kiedy mamy z nim do czynienia, to wiemy że mamy do wyboru ograniczony zbiór możliwych opcji. Przykładowo, definiując enum <code>poraRoku</code> z góry wiemy, że będzie on przyjmować wartości jedynie spośród <em><code>ZIMA</code></em>, <em><code>WIOSNA</code></em>, <em><code>LATO</code></em> i <em><code>JESIEN</code></em>.</p>

<p>Każdy enum domyślnie rozszerza klasę <code>java.lang.Enum</code>, dlatego nie może rozszerzać żadnej innej klasy. Może natomiast implementować interfejsy. Enumy możemy definiować również jako klasy wewnętrzne.</p>

<p>Konstruktor może być <code>protected</code> (domyślnie) albo <code>private</code>. Nie przywołujemy go bezpośrednio. Weźmy nasz enum <code>poraRoku</code>:</p>

<pre><code class="language-Java">    class EnumCwiczenie {
      enum poraRoku {
        ZIMA, WIOSNA, LATO, JESIEN
      }

      public static void main(String[] args) {
        System.out.println(poraRoku.LATO + &quot; to okres strasznej duchoty.&quot;);
      }
    }
</code></pre>

<p>Efekt: <code>LATO to okres strasznej duchoty.</code></p>

<p>Ciało klasy (<em>typu</em>) enum może zawierać metody i inne pola. Domyślnie w trakcie kompilacji dodawana jest metoda <code>values()</code>, zwracająca tablicę wszystkich wartości naszego enum w kolejności ich deklaracji w kodzie. Zobaczmy jak możemy zawrzeć więcej informacji w stałych enum:</p>

<pre><code class="language-Java">    class EnumCwiczenie {
      enum poraRoku {
        ZIMA(&quot;Gwiazdka&quot;), WIOSNA(&quot;Wielkanoc&quot;), LATO(&quot;Noc Kupaly&quot;), JESIEN(&quot;Zaduszki&quot;);

        private final String waznaData;

        poraRoku(String waznaData) {
          this.waznaData = waznaData;
        }

        String getWaznaData() {
          return waznaData;
        }
      }

      public static void main(String[] args) {
        System.out.println(poraRoku.LATO + &quot; to okres strasznej duchoty.&quot;);
        System.out.println(&quot;W trakcie tej pory roku ma miejsce &quot; + poraRoku.LATO.getWaznaData() + &quot;.&quot;);

        for(poraRoku pora : poraRoku.values()) {
          System.out.println(&quot;W trakcie pory &quot; + pora + &quot; ma miejsce &quot; + pora.getWaznaData() + &quot;.&quot;);
        }
      }
    }
</code></pre>

<p>Efekt:</p>

<pre><code>    LATO to okres strasznej duchoty.
    W trakcie tej pory roku ma miejsce Noc Kupaly.
    W trakcie pory ZIMA ma miejsce Gwiazdka.
    W trakcie pory WIOSNA ma miejsce Wielkanoc.
    W trakcie pory LATO ma miejsce Noc Kupaly.
    W trakcie pory JESIEN ma miejsce Zaduszki.
</code></pre>

<p>Pełen zbiór domyślnych metod znaleźć można w <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Enum.html">dokumentacji</a>.</p>

<h3 id="kiedy-stosować">Kiedy stosować?</h3>

<p>Korzystając z enuma, mamy zagwarantowane istnienie tylko jednej instancji stałej (wygodny punkt wyjścia dla wzorca <a href="http://keaplogik.blogspot.com/2013/12/the-java-enum-singleton-pattern.html">Singleton</a>). Ponadto, możemy korzystać z operatora <code>==</code>. Zawarta w klasie <code>Enum</code> metoda <code>equals()</code> działa dokładnie tak samo jak ten operator, ale jest metodą, więc możemy otrzymać wyjątek <code>NullPointerException</code>, zamiast wartości <code>false</code> jak w przypadku porównania enum przy pomocy <code>==</code> z <code>null</code>.</p>

<p>Nie trzeba implementować interfejsu <code>Serializable</code> by móc serializować enumy. Ponadto, dokonując serializacji enuma, <em>de facto</em> serializowana jest jego nazwa, zwracana przez wbudowaną metodę <code>name()</code>, a przy deserializacji przywoływana jest metoda <code>valueOf()</code> naszego enuma, zwracająca stałą o tej nazwie. W ten sposób nie musimy serializować wartości wszytkich pól enuma.</p>

<p>Enumy pozwalają także na wygodniejsze stosowanie wyrażeń <code>switch</code>:</p>

<pre><code class="language-Java">    poraRoku jednaPoraRoku = poraRoku.WIOSNA;
    switch(jednaPoraRoku) {
      case LATO:
        System.out.println(&quot;Cieplo!&quot;);
        break;
      case ZIMA:
        System.out.println(&quot;Zimno!&quot;);
        break;
      case WIOSNA:
        System.out.println(&quot;W sam raz!&quot;);
        break;
      case JESIEN:
        System.out.println(&quot;Mokro!&quot;);
        break;
    }
</code></pre>

<p>Efekt: <code>W sam raz!</code></p>

<p>Nie zawsze stosowanie typu enum jest korzystne. Zajmują one więcej miejsca w pamięci (powód dla którego ich stosowanie <a href="https://developer.android.com/topic/performance/memory.html#Overhead">nie jest rekomendowane</a> przez zespół Androida). Jeżeli nasze stałe nie mają żadnych dodatkowych pól, to prawdopodobnie mniej zasobów będzie zajmować zwyczajowe <code>public static final</code>.
Z drugiej strony, enumy są łatwym sposobem obsługi stałych, które mają posiadać dodatkowe pola (a zatem więcej informacji) i własne metody.</p>

<p>Czyli, jak zawsze, stosować w sposób przemyślany ;).</p>

<h2 id="prosta-aplikacja-webowa-servlets-tomcat">Prosta aplikacja webowa: Servlets, Tomcat</h2>

<p>Mówiąc w skrócie, servlety to klasy pomagające serwerowi w odpowiadaniu na żądania ze strony klienta. Jako że najczęściej żądania są w protokole HTTP, to pisząc servlet zwykle rozszerzamy klasę <code>javax.servlet.http.HttpServlet</code>, i nie bawimy się w implementację samego interfejsu <code>javax.servlet.Servlet</code>.</p>

<p>Zwróćcie uwagę na początek tych nazw: java<strong>x</strong>, nie zwykłe java. Standardowa edycja Javy nie zawiera servletów, Jeżeli używaliście wcześniej platformy Javy SE, to będziecie musieli ściągnąć brakujące biblioteki, albo po prostu przerzucić się na Javę EE, która je (i inne) zawiera. Przykładowo, jeśli korzystacie z Eclipse&rsquo;a, macie do wyboru <a href="https://www.eclipse.org/ide/">kilka wersji</a> programu. Zainstalujcie <a href="https://www.eclipse.org/downloads/packages/eclipse-ide-java-ee-developers/oxygenr">wersję dla Javy EE </a>i będziecie mieć spokój ;).</p>

<p>Potrzebny jest też serwer oraz (akurat dla potrzeb takich servletów, jakie napiszemy) baza danych. W poniższych przykładach wykorzystany jest <a href="http://tomcat.apache.org">Tomcat</a> oraz <a href="https://www.mysql.com">MySQL</a>. Nie będziemy krok po kroku przerabiać ich instalacji, w internecie bez problemu można znaleźć instrukcje do każdego systemu operacyjnego. Za pierwszym razem może to trochę czasu zająć, szczególnie jeśli się nie miało wcześniej do czynienia z linią komend, ale warto tę chwilę poświęcić. Założenie jest zatem takie, że Tomcat jest zainstalowany, a na dysku utworzona została baza danych MySQL.</p>

<p><code>javax.servlet.http.HttpServlet</code> zawiera <a href="http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServlet.html">szereg metod</a> odpowiadającym żądaniom HTTP. Skorzystamy z metod <code>doGet()</code> oraz <code>doPost()</code>. Różnica pomiędzy GET a POST polega na widoczności przesyłanych danych. Żądanie GET zawiera przesyłane do serwera informacje w adresie URL (można więc podejrzeć je nawet w historii przeglądarki), stąd dane muszą być zapisane za pomocą znaków ASCII. Przeglądarki i serwery nakładają ograniczenia na maksymalną długość adresu URL (od 2048 w górę), więc i z tej perspektywy jesteśmy ograniczeni. Dla żądania POST format danych nie jest tak istotny.</p>

<p>Napiszemy bardzo prostą aplikację webową: pamiętnik operujący na lokalnym serwerze.</p>

<h3 id="przygotowania">Przygotowania*</h3>

<p>(*Eclipse, wszystko można zrobić bez pomocy IDE)</p>

<p>Potrzebny jest nam nowy projekt, skonfigurowany do działania na serwerze. W Eclipse klikamy <strong>File </strong>-&gt; <strong>New </strong>-&gt; <strong>Dynamic Web Project</strong>. Po podaniu nazwy projektu, obok pola <em>Target runtime</em> klikamy przycisk <em>New Runtime&hellip;</em>, wybieramy wersję Tomcata, klikamy <em>Finish</em>. Kreator projektu również zamykamy klikając <em>Finish</em>. Ok, mamy lokalny serwer, na którym będziemy odpalać nasze servlety.</p>

<p>Teraz baza danych. Upewnij się, że masz włączony domyślną perspektywę w Eclipse (<em>Window </em>-&gt; <em>Perspective</em> -&gt; <em>Open perspective</em> -&gt; <em>Java EE</em>). U dołu okna IDE kliknij w <em>Data Source Explorer</em> i prawym przycikiem myszy na <em>Database Connections</em>. Kliknij <em>New</em>, z listy wybierz MySQL. Po naciśnięciu <em>Next</em> wpisz dane do swojej bazy danych (nazwa pod polem <em>Database</em>, pełen URL, login i hasło). Jeżeli po naciśnięciu <em>Test Connection</em> pokazuje się komunikat o niepowodzeniu, sprawdź wybrany sterownik. W naszym wypadku jest to JDBC Driver, ściągnąć go można <a href="https://www.mysql.com/products/connector/">tutaj.</a> a zmienić naciskając na ikonę trójkąta po prawej strony od listy sterowników, wskazując na miejsce, gdzie tenże .jar znajduje się na dysku.</p>

<p><img src="/images/oldblog/20-07_servlet_databasedriver.png" alt="image-center" />{: .align-center}</p>

<p>W naszym wypadku baza danych nazywa się <code>diary</code>, a przygotowana wcześniej tabela <code>ENTRIES</code>, z następującymi kolumnami:</p>

<pre><code class="language-SQL">    CREATE TABLE ENTRIES(
        id INT NOT NULL AUTO_INCREMENT,
        title VARCHAR(200),
        date DATETIME,
        content LONGTEXT,
        PRIMARY KEY ( id )
    );
</code></pre>

<h3 id="servlet-pobierający-informacje-z-bazy-danych">Servlet pobierający informacje z bazy danych</h3>

<p>Tak jak wyżej napisano, servlety służące do obsługi żądań HTTP powinny rozszerzać klasę <code>javax.servlet.http.HttpServlet</code>. A więc:</p>

<pre><code class="language-Java">    @WebServlet(&quot;/DiaryArchive&quot;)
    public class DiaryArchive extends HttpServlet {
    }
</code></pre>

<p>Kilka słów o <a href="http://docs.oracle.com/javaee/7/api/javax/servlet/annotation/WebServlet.html"><code>@WebServlet</code></a>. Pojawiła się ona w specyfikacji <a href="http://download.oracle.com/otn-pub/jcp/servlet-3.0-fr-eval-oth-JSpec/servlet-3_0-final-spec.pdf?AuthParam=1500537336_edf2e70ab23c230015d7612efce60f3d">Servlet 3.0</a>. Wcześniej dla każdej aplikacji sieciowej obsługiwanej przy pomocy servletów należało tworzyć deskryptor w pliku <code>web.xml</code>, w którym m.in. umieszczaliśmy informacje na temat wszystkich servletów. Dzięki temu kontener servletów (w naszym przypadku Tomcat) wiedział, który servlet powinien odpalić na dany typ żądania ze strony klienta. Adnotacja <code>@WebServlet</code> ułatwia nam pracę, takowego pliku przygotowywać nie trzeba (Tomcat ją obsługuje od wersji 7.0).</p>

<p>W dokumentacji wymieniony jest szereg atrybutów adnotacji, ale podawać trzeba jedynie <code>urlPatterns</code>/<code>value</code>, wskazując URL pod którym nasz servlet będzie aktywny.</p>

<p>Nasz pierwszy servlet będzie służyć do odczytywania z bazy danych wpisów z pamiętnika. Żadnych specjalnych danych do serwera nie przesyłamy, tylko żądanie wyświetlenia wpisów, więc skorzystamy z żądania GET, a więc przesłaniamy metodę <code>doGet()</code>. Od razu ustalimy typ odpowiedzi (będzie to wyświetlany w przeglądarce html) oraz przygotujemy przypiszemy zmienną <strong>out</strong> do obiektu <code>PrintWriter</code> wziętego z <code>HttpServletResponse</code>. Ten posłuży nam do przesłania tekstu (kodu html) do klienta:</p>

<pre><code class="language-Java">    protected void doGet(HttpServletRequest request, HttpServletResponse response) 
          throws ServletException, IOException {
                    response.setContentType(&quot;text/html&quot;);
                    PrintWriter out = response.getWriter();
    }
</code></pre>

<p>Czas na małe parsowanie. Najpierw część kodu html, do którego nie potrzebujemy informacji z bazy danych:</p>

<pre><code class="language-Java">    String title = &quot;My Db Diary&quot;;
    String docType =  &quot;&lt;!DOCTYPE html&gt;\n&quot;;

    out.println(docType + 
        &quot;&lt;html&gt;\n&quot; +
        &quot;&lt;head&gt;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&lt;/header&gt;\n&quot; +
        &quot;&lt;body bgcolor = \&quot;#f3f3f3\&quot;&gt;\n&quot; +
        &quot;&lt;h1 align = \&quot;center\&quot;&gt;&quot; + title + &quot;&lt;/h1&gt;\n&quot; +
        &quot;&lt;h3 align = \&quot;center\&quot;&gt;&lt;a href=\&quot;http://localhost:8080/DiaryServlet/DiaryMain.html\&quot;&gt;Add new entry&lt;/a&gt;&lt;/h3&gt;&quot;);
</code></pre>

<p>Od razu zawarliśmy w nim URL, pod którym będzie działać nasz drugi servlet. Na razie wejście pod ten adres wywołałoby jedynie błędy.</p>

<p>Pozostaje nam połączenie się z bazą danych, pobranie wpisów i sparsowanie ich do kodu HTML. Najpierw kilka stałych:</p>

<pre><code class="language-Java">    private static final String JDBC_DRIVER = &quot;com.mysql.jdbc.Driver&quot;;
    private static final String DB_URL = &quot;jdbc:mysql://localhost:3306/diary&quot;;  // Adres naszej bazy MySQL
    private static final String USER = &quot;root&quot;; // Login do bazy
    private static final String PASS = &quot;root&quot;; // Hasło do bazy

    try {	
      // Rejestrujemy sterownik.
      Class.forName(JDBC_DRIVER);

            // Podłączamy się do naszej bazy MySQL
      Connection con = DriverManager.getConnection(DB_URL, USER, PASS);

            // Przygotowujemy zapytanie do bazy oraz obiekt klasy ResultSet z danymi zwrotnymi.
      Statement stmt = con.createStatement();
      String sql = &quot;SELECT id, date, title, content FROM ENTRIES&quot;;
      ResultSet rs = stmt.executeQuery(sql);

            // Parsujemy każdy kolejny wiersz pobrany do obiektu ResultSet do kodu HTML.
      while(rs.next()) {
        int id = rs.getInt(&quot;id&quot;);
        Timestamp ts = rs.getTimestamp(&quot;date&quot;);
        String entryTitle = rs.getString(&quot;title&quot;);
        String entryContent = rs.getString(&quot;content&quot;);

        out.println(&quot;&lt;h3 align = \&quot;center\&quot;&gt;&quot; + id + &quot;: &quot; + ts.toString() + &quot;&lt;/h3&gt;&quot;);
        out.println(&quot;&lt;h2 align = \&quot;center\&quot;&gt;&quot; + entryTitle + &quot;&lt;/h2&gt;&lt;br&gt;&quot;);
        out.println(entryContent + &quot;&lt;br&gt;&quot;);
      }
      out.println(&quot;&lt;/body&gt;&lt;/html&gt;&quot;);
      
            // Zamykamy połączenia z bazą danych (dla przejrzystości przykładu zakładamy, że nie wystąpią w tym miejscu wyjątki).	
      rs.close();
      stmt.close();
      con.close();
    } catch(SQLException se) {
      se.printStackTrace();
    } catch(Exception e) {
      e.printStackTrace();
    }
</code></pre>

<p>Pierwszy servlet gotowy. Gdy klikniemy <em>Run</em> -&gt; <em>Run as&hellip;</em> -&gt; <em>Run on Server</em> powinniśmy ujrzeć coś takiego:</p>

<p><img src="/images/oldblog/20-07servlet_effect1.png" alt="image-center" />{: .align-center}</p>

<p>Zwróćcie uwagę, że adres URL to połączony adres bazy danych oraz adresu podanego w adnotacji <code>@WebServlet</code>.</p>

<p>Czas na drugi servlet, pozwalający na dodawanie nowych wpisów do bazy. Jak widać podany adres servleta nie musi pokrywać się z nazwą klasy:</p>

<pre><code class="language-Java">    @WebServlet(&quot;/DiaryNew&quot;)
    public class UploadEntryServlet extends HttpServlet {
            private static final String JDBC_DRIVER = &quot;com.mysql.jdbc.Driver&quot;;
            private static final String DB_URL = &quot;jdbc:mysql://localhost:3306/diary&quot;;
            private static final String USER = &quot;root&quot;;
            private static final String PASS = &quot;root&quot;;
    }
</code></pre>

<p>Tym razem skorzystamy z żądania POST, bo inaczej cała treść wpisu w żądaniu GET musiałaby wejść w adres URL. Przesłaniamy metodę <code>doPost()</code>:</p>

<pre><code class="language-Java">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // Tym razem pobieramy informacje z obiektu HttpServletRequest 
        String entryTitle = request.getParameter(&quot;title&quot;);
        String content = request.getParameter(&quot;entry&quot;);
        // Jedna z kolumn w bazie jest typu DATETIME, potrzebujemy więc obiektu Timestamp z aktualną datą.
        Timestamp timestamp = new Timestamp(System.currentTimeMillis());
        
        try {
          Class.forName(JDBC_DRIVER);
          
          Connection con = DriverManager.getConnection(DB_URL, USER, PASS);
          
          // Przygotowujemy dane do wysłania do bazy.
          String sql = &quot;INSERT INTO ENTRIES (content, date, title) values (?, ?, ?)&quot;;
          PreparedStatement statement = con.prepareStatement(sql);
          statement.setString(1, content);
          statement.setString(3,  entryTitle);
          statement.setTimestamp(2, timestamp);
          
          // Wysyłamy przygotowane dane do bazy i zamykamy połączenia.
          statement.executeUpdate();
          statement.close();
          con.close();
        } catch(SQLException se) {
          se.printStackTrace();
        } catch(Exception e) {
          e.printStackTrace();
        }
        // Po wysłaniu wpisu do bazy, przejdź pod URL pierwszego servleta i pokaż zawartość pamiętnika 
        response.sendRedirect(&quot;DiaryArchive&quot;);
      }
</code></pre>

<p>Gdybyśmy spróbowali odpalić ten servlet na serwerze, wyskoczy nam błąd 405. Nie wysłaliśmy bowiem żądania POST, więc sprawdzane jest (po adresie URL) żądanie GET, a tego nasz servlet nie obsługuje. Musimy przygotować plik .html do obsługi naszego servleta. Umieścimy go w projekcie w folderze <em>WebContent</em>/<em>WEB-INF</em>:</p>

<p><img src="/images/oldblog/20-07servlet_htmlplace.png" alt="image-center" />{: .align-center}</p>

<p>Przesyłane są informacje zawarte pomiędzy znacznikami <code>&lt;form&gt;</code> i <code>&lt;/form&gt;</code>, odzyskiwane w kodzie servleta poprzez atrybut <code>name</code>:</p>

<pre><code class="language-HTML">    &lt;!DOCTYPE html&gt;
    &lt;html&gt;
    &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;My Db Diary&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;h3 align=&quot;center&quot;&gt;Read your diary: &lt;a href=&quot;http://localhost:8080/DiaryServlet/DiaryArchive&quot;&gt;HERE&lt;/a&gt;&lt;/h3&gt;
    &lt;h3&gt;New Entry:&lt;/h3&gt;
          &lt;form action = &quot;DiaryNew&quot; method = &quot;post&quot;&gt;
             Title: &lt;input type = &quot;text&quot; name = &quot;title&quot;/&gt; &lt;br/&gt;
             Entry: &lt;br/&gt; &lt;textarea rows=&quot;20&quot; cols=&quot;90&quot; wrap=&quot;hard&quot; id=&quot;entryfield&quot; name=&quot;entry&quot;&gt;&lt;/textarea&gt; &lt;br/&gt;
             &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;/&gt;
          &lt;/form&gt;
    &lt;/body&gt;
    &lt;/html&gt;
</code></pre>

<p>Po odpaleniu zobaczymy coś takiego:</p>

<p><img src="/images/oldblog/20-07servlet_effect2.png" alt="image-center" />{: .align-center}</p>

<p>I to tyle! Mamy prosty (prostacki ;)) pamiętnik przetrzymywany w bazie danych, z którym łączymy się Javą poprzez serwer lokalny. Póki nie wyłączymy serwera ani bazy danych możemy łączyć się z pamiętnikiem przez dowolną przeglądarkę.</p>

<p>Pełen kod dostępny na <a href="https://github.com/MiWy/doksaprosta_blog_code_snippets/tree/master/Java101/20-07_servlets">GitHubie</a>.</p>

        </p>

        <div>
          <div class="post-back-link">
    <a href="javascript: history.back()">
        <i class="fa fa-arrow-left"></i> 
        Back
    </a>
</div>
        </div>
      </div>
    </div>
    

<footer>

</footer>

<script src="https://code.jquery.com/jquery-3.1.1.min.js"
  integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"
  integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<script src="/js/prism.js"></script>

</body>

</html>
