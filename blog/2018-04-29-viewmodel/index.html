<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Michał Wyrwa's Homepage">
  <meta name="author" content="Michał Wyrwa">
  
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@">
    <meta name="twitter:creator" content="@">
    <meta name="twitter:title" content="[OLD] ISS, Architecture: ViewModel, LiveData, Retrofit">
    <meta name="twitter:description" content="[This is a post from my old website. Outdated packages and libraries. Viewer discretion is advised ;-)]
W tym artykule stworzymy prostą aplikację na Android wyświetlającą aktualną pozycję Międzynarodowej Stacji Kosmicznej, wykorzystującą ViewModel, LiveData oraz bibliotekę Retrofit. Przy okazji wyjaśnimy jak działają dodane w zeszłym roku komponenty architektury Androida.
Aplikacja wyglądać będzie tak:
{: .align-center}
Komponenty architektury Androida Architecture Components to biblioteki dla Androida, zaprezentowane przez Google na I/O &lsquo;17.">

    <meta property="og:url" content="/blog/2018-04-29-viewmodel/" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content="[OLD] ISS, Architecture: ViewModel, LiveData, Retrofit" />
    <meta property="og:description" content="[This is a post from my old website. Outdated packages and libraries. Viewer discretion is advised ;-)]
W tym artykule stworzymy prostą aplikację na Android wyświetlającą aktualną pozycję Międzynarodowej Stacji Kosmicznej, wykorzystującą ViewModel, LiveData oraz bibliotekę Retrofit. Przy okazji wyjaśnimy jak działają dodane w zeszłym roku komponenty architektury Androida.
Aplikacja wyglądać będzie tak:
{: .align-center}
Komponenty architektury Androida Architecture Components to biblioteki dla Androida, zaprezentowane przez Google na I/O &lsquo;17." />


  <title>[OLD] ISS, Architecture: ViewModel, LiveData, Retrofit | Michał Wyrwa</title>

  <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <script src="https://kit.fontawesome.com/923575d7ad.js"></script>
  <link href="/css/prism.css" rel="stylesheet" />
  <link rel="stylesheet" href="/css/academicons.min.css" />
  <link href="/css/scarab.css" rel="stylesheet">
  
  
  

</head>

<body>

  <nav class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-navbar-collapse-1">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://miwy.github.io">Michał Wyrwa</a>
    </div>
    
    <div class="collapse navbar-collapse" id="bs-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li>
          <a href="/publications/">
            <i class="fa far fa-copy"></i>&nbsp;
            RESEARCH
          </a>
        </li>
        <li>
          <a href="/blog/">
            <i class="fa fas fa-quote-right"></i>&nbsp;
            BLOG
          </a>
        </li>
        <li>
          <a href="/teaching/">
            <i class="fa fas fa-user-graduate"></i>&nbsp;
            TEACHING
          </a>
        </li>
      </ul>
    </div>
  </div>
</nav>

  
  <div class="container">

    
    <div class="row">
      <div class="col-md-8 col-md-offset-2">

        <h2>[OLD] ISS, Architecture: ViewModel, LiveData, Retrofit</h1>
        <p>
          <em>Sun, Apr 29, 2018</em>
        </p>
        <p>
          

<p>[This is a post from my old website. Outdated packages and libraries. Viewer discretion is advised ;-)]</p>

<p>W tym artykule stworzymy prostą aplikację na Android wyświetlającą aktualną pozycję Międzynarodowej Stacji Kosmicznej, wykorzystującą ViewModel, LiveData oraz bibliotekę Retrofit. Przy okazji wyjaśnimy jak działają dodane w zeszłym roku komponenty architektury Androida.</p>

<p>Aplikacja wyglądać będzie tak:</p>

<p><img src="/images/oldblog/issfinishedappl.png" alt="image-center" />{: .align-center}</p>

<h2 id="komponenty-architektury-androida">Komponenty architektury Androida</h2>

<p><a href="https://developer.android.com/topic/libraries/architecture/">Architecture Components</a> to biblioteki dla Androida, zaprezentowane przez Google na <a href="https://www.youtube.com/watch?v=FrteWKKVyzI">I/O &lsquo;17</a>. Mają one ułatwić proces projektowania architektury aplikacji. Dotąd zespół Androida nie rekomendował żadnego konkretnego wzorca architektury. A tych popularnych trochę jest, by wymienić same <a href="https://medium.com/@vicky7230/android-architecture-patterns-mv-c-p-vm-4594574eeaa1"><em>model-view-*</em></a>.</p>

<p>Dodatkowe komponenty i rekomendowany przepływ danych można zobrazować tak:</p>

<p><img src="/images/oldblog/AndroidComponentsFlowChart1.png" alt="image-center" />{: .align-center}</p>

<p>Warstwa UI oddzielona jest od tej częsci kodu, która jest odpowiedzialna za zdobywanie i przygotowywanie danych przez <code>ViewModel</code>. Obiekty tej klasy nie są niszczone wskutek zmian konfiguracyjnych aplikacji (np. zmiany orientacji ekranu), są <em>lifecycle-aware</em>, więc nie ma już potrzeby pakowania multum danych w <code>onSaveInstanceState()</code>. ViewModel przetrwa, jeśli w Activity, w której był przywołany, zostanie użyte <code>onDestroy()</code>, o ile tylko nie będzie to się wiązało z wywołaniem metody <code>finish()</code> (więcej <a href="https://code.tutsplus.com/tutorials/android-architecture-components-lifecycle-and-livemodel--cms-29275">tutaj</a>).</p>

<p>Sam <code>ViewModel</code> również nie ma być odpowiedzialny za operacje na bazie danych albo zewnętrznym API, dostaje takie gotowe dane z <code>Repository</code>. Sama klasa Repository nie wchodzi w skład bibliotek Architecture Components. Obiekty należące do tej klasy mają pośredniczyć w wymianie danych pomiędzy źródłem danych (API/SQLite/itd.) a ViewModelem.</p>

<p>Biblioteka <code>Room</code> to warstwa abstrakcji nad SQLite, ułatwiająca (= mniej kodu) dostęp i manipulację danymi z bazy danych. Od strony RESTfulowych usług, pobierania danych spoza naszej aplikacji przy pomocy jakiegoś API, Android nie dostarcza gotowej biblioteki. W <a href="https://developer.android.com/topic/libraries/architecture/guide">dokumentacji</a> natomiast korzysta z <a href="http://square.github.io/retrofit/"><code>Retrofit</code></a>, stąd gwiazdka na diagramie :).</p>

<p>Pozostaje kwestia <a href="https://developer.android.com/topic/libraries/architecture/livedata"><code>LiveData</code></a>. Jest to <em>data holder</em>, który może być obserwowany.  Innymi słowy, jeśli nasze dane zostaną przekazane przez ViewModel do warstwy UI jako LiveData, to obserwowanie stanu danych w LiveData wystarczy, by przy zmianie w danych zmianie też uległa wyświetlana dla użytkownika treść na ekranie.</p>

<h2 id="aplikacja-whereisspacestation">Aplikacja WhereIsSpaceStation</h2>

<p>W tym wpisie zajmiemy się &ldquo;prawą stroną&rdquo; diagramy. Nie będziemy niczego zapisywać w bazie danych, wykorzystamy LiveData, ViewModel, Repository i Retrofit by wyświetlić na ekranie aktualną pozycję ISS. Po naciśnięciu przycisku informacja na ekranie będzie aktualizowana. W przyszłości dodamy też bazę danych.</p>

<p>Skorzystamy z:</p>

<ul>
<li><a href="https://developer.android.com/studio/">Android Studio</a> (na dzień pisania wpisu jest to wersja 3.1.1)</li>
<li><a href="http://open-notify.org/Open-Notify-API/">OpenNotify API</a></li>
<li><a href="http://square.github.io/retrofit/">Retrofit</a></li>
<li>Biblioteki <a href="https://developer.android.com/topic/libraries/architecture/">Architecture Components</a></li>
</ul>

<h3 id="ustawienia-projektu">Ustawienia projektu</h3>

<p>Tworzymy nowy projekt w Android Studio:</p>

<p><img src="/images/oldblog/Screen-Shot-2018-04-29-at-10.47.55.png" alt="image-center" />{: .align-center}</p>

<p><img src="/images/oldblog/Screen-Shot-2018-04-29-at-10.48.07.png" alt="image-center" />{: .align-center}</p>

<p>Resztę ustawień pozostawiamy domyślne. Kreator powinien nam stworzyć nowy projekt, z jedną Activity (wedle templatki EmptyActivity).</p>

<p>Nasza aplikacja będzie korzystać z połączenia z internetem, więc w <code>AndroidManifest.xml</code> musimy dodać:</p>

<pre><code class="language-xml">    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;
</code></pre>

<p>Architecture Components na dzień dzisiejszy trzeba ręcznie dodać do projektu. W <code>build.gradle</code> projektu sprawdzamy, czy wśród repozytoriów znajduje się google():</p>

<pre><code class="language-gradle">    repositories {
           google()
           jcenter()
       }
</code></pre>

<p>A w <code>build.gradle</code> na poziomie modułu aplikacji dodajemy potrzebne biblioteki. Aktualne wersje bibliotek znaleźć można <a href="https://developer.android.com/topic/libraries/architecture/adding-components">tutaj</a>:</p>

<pre><code class="language-gradle">    dependencies {
        implementation fileTree(dir: 'libs', include: ['*.jar'])
        implementation 'com.android.support:appcompat-v7:27.1.0'
        implementation 'com.android.support.constraint:constraint-layout:1.1.0'
        testImplementation 'junit:junit:4.12'
        androidTestImplementation 'com.android.support.test:runner:1.0.1'
        androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.1'
    
        // Javax annotation
        implementation 'org.glassfish:javax.annotation:10.0-b28'
    
        // Retrofit
        implementation 'com.squareup.retrofit2:retrofit:2.4.0'
        implementation 'com.squareup.retrofit2:converter-gson:2.4.0'
    
        // ViewModel and LiveData
        implementation &quot;android.arch.lifecycle:extensions:1.1.1&quot;
        // alternatively, just ViewModel
        implementation &quot;android.arch.lifecycle:viewmodel:1.1.1&quot;
        // alternatively, just LiveData
        implementation &quot;android.arch.lifecycle:livedata:1.1.1&quot;
    
        annotationProcessor &quot;android.arch.lifecycle:compiler:1.1.1&quot;
    
        // Room (use 1.1.0-beta3 for latest beta)
        implementation &quot;android.arch.persistence.room:runtime:1.0.0&quot;
        annotationProcessor &quot;android.arch.persistence.room:compiler:1.0.0&quot;
    
        // Paging
        implementation &quot;android.arch.paging:runtime:1.0.0-rc1&quot;
    
        // Test helpers for LiveData
        testImplementation &quot;android.arch.core:core-testing:1.1.1&quot;
    
        // Test helpers for Room
        testImplementation &quot;android.arch.persistence.room:testing:1.0.0&quot;
    }
</code></pre>

<p>Synchronizujemy i budujemy projekt, sprawdzając, czy nie ma błędów kompilacji :).</p>

<h3 id="resources">Resources</h3>

<p>Nasza aplikacja będzie bardzo prosta, więc możemy od razu ustawić potrzebne pliki w katalogu <code>res</code>.</p>

<p>W strings.xml dodajemy kilka Stringów:</p>

<pre><code class="language-xml">    &lt;resources&gt;
        &lt;string name=&quot;app_name&quot;&gt;WhereIsSpaceStation&lt;/string&gt;
        &lt;string name=&quot;header_note&quot;&gt;Where is the International Space Station now?&lt;/string&gt;
        &lt;string name=&quot;button_text&quot;&gt;Check!&lt;/string&gt;
        &lt;string name=&quot;response_empty&quot;&gt;It seems we did not receive any data this time.&lt;/string&gt;
        &lt;string name=&quot;response_failure&quot;&gt;It seems you have some internet connection problems.&lt;/string&gt;
    &lt;/resources&gt;
</code></pre>

<p>A w pliku XML naszego Activity (MainActivity.xml):</p>

<pre><code class="language-xml">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
        xmlns:tools=&quot;http://schemas.android.com/tools&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        tools:context=&quot;.MainActivity&quot;&gt;
    
        &lt;TextView
            android:id=&quot;@+id/header&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;@string/header_note&quot;
            android:textSize=&quot;16sp&quot;
            app:layout_constraintBottom_toTopOf=&quot;@id/coordinates&quot;
            app:layout_constraintLeft_toLeftOf=&quot;parent&quot;
            app:layout_constraintRight_toRightOf=&quot;parent&quot;
            app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;
    
        &lt;TextView
            android:id=&quot;@+id/coordinates&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;&quot;
            app:layout_constraintBottom_toTopOf=&quot;@id/checkButton&quot;
            app:layout_constraintLeft_toLeftOf=&quot;parent&quot;
            app:layout_constraintRight_toRightOf=&quot;parent&quot;
            app:layout_constraintTop_toBottomOf=&quot;@id/header&quot; /&gt;
    
    
        &lt;Button
            android:id=&quot;@+id/checkButton&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;@string/button_text&quot;
            app:layout_constraintTop_toBottomOf=&quot;@id/coordinates&quot;
            app:layout_constraintBottom_toBottomOf=&quot;parent&quot;
            app:layout_constraintLeft_toLeftOf=&quot;parent&quot;
            app:layout_constraintRight_toRightOf=&quot;parent&quot;/&gt;
    
    
    &lt;/android.support.constraint.ConstraintLayout&gt;
</code></pre>

<p>Na nasze UI składać się będzie (oprócz paska aplikacji): TextView z na sztywno ustawionym tekstem (&ldquo;Where is the ISS now?&rdquo;), TextView, w którym wyświetlać będziemy lokalizację ISS oraz Button, którego naciśnięcie zaktualizuje dane o lokalizacji.</p>

<h3 id="konfiguracja-retrofit">Konfiguracja Retrofit</h3>

<p>Ustawienie Retrofit jest bardzo proste. Potrzebujemy adresu, pod który wysyłane będzie żądanie, POJO, w których Retrofit będzie zapisywać dane zwrotne i jednego interfejsu.</p>

<p>OpenNotify, API z którego skorzystamy, jest bardzo przyjemne, bo nie wymaga żadnej autoryzacji. Adres, pod którym znajdują się potrzebne nam dane o lokalizacji ISS jest taki: <a href="http://api.open-notify.org/iss-now.json"><code>http://api.open-notify.org/iss-now.json</code></a>. Jak widać, dane zwrotne są w postaci JSON, będziemy musieli poinformować o tym Retrofit przy konfiguracji.</p>

<p>POJO wraz z anotacjami możemy wykreować automatycznie. W Android Studio istnieje możliwość używania pluginów. Klikamy w Preferences-&gt;Plugins, wpisujemy <code>Json2Pojo</code>, instalujemy i restartujemy IDE.</p>

<p><img src="/images/oldblog/Screen-Shot-2018-04-29-at-11.09.35.png" alt="image-center" />{: .align-center}</p>

<p>Stworzymy sobie osobną paczkę do POJO. W widoku struktury projektu z lewej strony programu klikamy na główną paczkę naszego projektu prawym przyciskiem myszy, następnie New-&gt;Package. Nazywamy ją &ldquo;<code>pojos</code>&rdquo;. Klikamy prawym na pojos, New-&gt;Create POJOs from JSON. W Root Class Name wpisujemy nazwę naszego POJO: <code>IssLocationJSON</code>, a w okienku przeklejamy JSON z <a href="http://api.open-notify.org/iss-now.json">OpenNotify</a>. Klikamy OK.</p>

<p>Plugin powinien wygenerować dwie klasy: <code>IssLocationJSON</code> oraz <code>IssPosition</code>. Dla porównania, kod dla IssLocationJSON:</p>

<pre><code class="language-Java">    @Generated(&quot;net.hexar.json2pojo&quot;)
    @SuppressWarnings(&quot;unused&quot;)
    public class IssLocationJSON {
    
        @SerializedName(&quot;iss_position&quot;)
        private IssPosition mIssPosition;
        @SerializedName(&quot;message&quot;)
        private String mMessage;
        @SerializedName(&quot;timestamp&quot;)
        private Long mTimestamp;
    
        public IssPosition getIssPosition() {
            return mIssPosition;
        }
    
        public void setIssPosition(IssPosition issPosition) {
            mIssPosition = issPosition;
        }
    
        public String getMessage() {
            return mMessage;
        }
    
        public void setMessage(String message) {
            mMessage = message;
        }
    
        public Long getTimestamp() {
            return mTimestamp;
        }
    
        public void setTimestamp(Long timestamp) {
            mTimestamp = timestamp;
        }
    
    }
</code></pre>

<p>Oraz dla IssPosition:</p>

<pre><code class="language-java">    @Generated(&quot;net.hexar.json2pojo&quot;)
    @SuppressWarnings(&quot;unused&quot;)
    public class IssPosition {
    
        @SerializedName(&quot;latitude&quot;)
        private String mLatitude;
        @SerializedName(&quot;longitude&quot;)
        private String mLongitude;
    
        public String getLatitude() {
            return mLatitude;
        }
    
        public void setLatitude(String latitude) {
            mLatitude = latitude;
        }
    
        public String getLongitude() {
            return mLongitude;
        }
    
        public void setLongitude(String longitude) {
            mLongitude = longitude;
        }
    
    }
</code></pre>

<p>W głównym folderze z kodem źródłowym, czyli obok paczki pojos, tworzymy paczkę api. W niej tworzymy interfejs dla Retrofit o nazwie <code>OpenNotifyService</code>. Ma on tylko jedną metodę abstrakcyjną: <code>getIssLocation()</code>. Anotujemy ją Retrofitowym <code>@GET</code>, podając ścieżkę do interesującego nas node&rsquo;u API (czyli co jest po slashu głównego adresu):</p>

<pre><code class="language-java">    public interface OpenNotifyService {
    
        @GET(&quot;iss-now&quot;)
        Call&lt;IssLocationJSON&gt; getIssLocation();
    }
</code></pre>

<p>Mamy już interfejs, POJO i adres.</p>

<p>Później zapiszemy dane zwrotne z lokalizacją w LiveData. LiveData nie ma jednak wbudowanego sposobu na radzenie sobie z żądaniami internetowymi. A co jeśli użytkownik nie będzie mieć połączenia internetowego albo serwer OpenNotify przestanie działać? Zwrócimy null? Dokumentacja sugeruje <a href="https://developer.android.com/topic/libraries/architecture/guide#addendum">takie</a> rozwiązanie, ale na nasze minimalne potrzeby wystarczy dużo prostsze. Zrobimy wrapper dla naszych IssLocationJSON, posiadający pole informujące nas o stanie połączenia. Instancje tego wrappera zapiszemy dopiero jako LiveData. Wówczas będziemy mieli dostęp do informacji, czy posiadamy dane o lokalizacji ISS, czy też ich nie mamy, bez problemów z nullami.</p>

<p>W paczce pojos tworzymy klasę <code>IssLocationWrapper</code>:</p>

<pre><code class="language-java">    package whereisspacestation.com.tryouts.whereisspacestation.pojos;
    
    public class IssLocationWrapper {
    
        private IssLocationJSON mIssLocationJson;
        private int mResponseStatus;
    
    
        public IssLocationJSON getIssLocationJson() {
            return mIssLocationJson;
        }
    
        public void setIssLocationJson(IssLocationJSON mIssLocationJson) {
            this.mIssLocationJson = mIssLocationJson;
        }
    
        public int getResponseStatus() {
            return mResponseStatus;
        }
    
        public void setResponseStatus(int mResponseStatus) {
            this.mResponseStatus = mResponseStatus;
        }
    }
</code></pre>

<p>Stworzymy też abstrakcyjną klasę <code>Status</code> ze statycznymi kodami dla statusu naszego wrappera. Tworzymy paczkę <code>util</code> i w niej klasę <code>Status</code> (pewnie bardziej elegancko byłoby użyć enumów, ale dla naszych potrzeb wystarczą zwykłe integery):</p>

<pre><code class="language-java">    package whereisspacestation.com.tryouts.whereisspacestation.util;
    
    public abstract class Status {
        private final static int RESPONSE_OK = 1;
        private final static int RESPONSE_EMPTY = 0;
        private final static int RESPONSE_FAILURE = -1;
    
    
        public static int getResponseOk() {
            return RESPONSE_OK;
        }
    
        public static int getResponseEmpty() {
            return RESPONSE_EMPTY;
        }
    
        public static int getResponseFailure() {
            return RESPONSE_FAILURE;
        }
    }
</code></pre>

<h3 id="repository">Repository</h3>

<p>Możemy już stworzyć instancję klasy <code>Retrofit</code>, która będzie zczytywać dane o lokalizacji ISS z serwera. Mając w pamięci diagram przepływu danych z komponentami architektury Androida, musimy stworzyć <code>Repository</code>.</p>

<p>Tworzymy paczkę <code>repository</code>, a w niej klasę <code>IssLocationRepository</code>:</p>

<pre><code class="language-java">    public class IssLocationRepository {
    
        private static final String BASE_URL = &quot;http://api.open-notify.org/&quot;;
        private static Retrofit mRetrofit;
        private static OpenNotifyService service;
        private MutableLiveData&lt;IssLocationWrapper&gt; mSpaceStationLocation;
    
        public IssLocationRepository() {
    
            mRetrofit = new Retrofit.Builder()
                    .baseUrl(BASE_URL)
                    .addConverterFactory(GsonConverterFactory.create())
                    .build();
            service = mRetrofit.create(OpenNotifyService.class);
            mSpaceStationLocation = new MutableLiveData&lt;&gt;();
    
            setLocation();
        }
    
    
        public void setLocation() {
            final IssLocationWrapper issLocationWrapper = new IssLocationWrapper();
            service.getIssLocation().enqueue(new Callback&lt;IssLocationJSON&gt;() {
                @Override
                public void onResponse(Call&lt;IssLocationJSON&gt; call, Response&lt;IssLocationJSON&gt; response) {
                    if(response.isSuccessful()) {
                        IssLocationJSON location = response.body();
                        if(location != null) {
                            issLocationWrapper.setIssLocationJson(location);
                            issLocationWrapper.setResponseStatus(Status.getResponseOk());
                            mSpaceStationLocation.postValue(issLocationWrapper);
                        } else {
                            issLocationWrapper.setResponseStatus(Status.getResponseEmpty());
                            mSpaceStationLocation.postValue(issLocationWrapper);
                        } 
                    } else {
                        issLocationWrapper.setResponseStatus(Status.getResponseEmpty());
                        mSpaceStationLocation.postValue(issLocationWrapper);
                    }
                }
    
                @Override
                public void onFailure(Call&lt;IssLocationJSON&gt; call, Throwable t) {
                    issLocationWrapper.setResponseStatus(Status.getResponseFailure());
                    mSpaceStationLocation.postValue(issLocationWrapper);
                }
            });
        }
    
    
        public MutableLiveData&lt;IssLocationWrapper&gt; getLocation() {
            return mSpaceStationLocation;
        }
    }
</code></pre>

<p>Od razu korzystamy z LiveData (w tym wypadku <code>MutableLiveData</code>, które różni się tylko tym, że upublicznia nam metody do zapisu danych w LiveData), bo z metody <code>getLocation()</code> będzie korzystać ViewModel.</p>

<p>W konstruktorze konfigurujemy <code>Retrofit</code>: podajemy bazowe URL API, informujemy, z jakiego konwertera ma korzystać (GSON w tym wypadku, z racji na stosowany w OpenNotify JSON), no i jakie żądania ma obsługiwać (nasz OpenNotifyService).</p>

<p>Metoda <code>setLocation()</code> wykonuje żądanie GET asynchronicznie, stąd <code>.enqueue</code> i <code>CallBack</code>. Jeśli nie ma połączenia z internetem wywołana zostanie przeciążona metoda <code>onFailure()</code>. Metoda <code>onResponse()</code> natomiast zostanie wywołana, jeśli otrzymamy odpowiedź z serwera. Jeśli wartość <code>response.isSuccesful()</code> jest false, to najwyraźniej dostaliśmy odpowiedź 404, 500 albo inną odpowiedź błędu, ale nie dostaliśmy w odpowiedzi danych o lokalizacji ISS, na których nam zależało. Może też się zdarzyć, że nasze żądanie zostanie przesunięte pod inny adres, ale nie otrzymamy odpowiedzi o błędnym adresie, bo adres działa (nie ma pod nim żadnych istotnych dla nas danych).</p>

<p>We wszystkich tych przypadkach, a także kiedy po prostu otrzymujemy interesujące nas dane (hurra), stosownie konfigurujemy obiekt <code>MutableLiveData&lt;IssLocationWrapper&gt;</code>.</p>

<p>Nic więcej w naszym Repository nie musimy dodawać.</p>

<h3 id="viewmodel">ViewModel</h3>

<p>Konstrukcja i struktura ViewModel w naszym przypadku jest bardzo prosta: tworzymy nową klasę, rozszerzającą klasę ViewModel o nazwie <code>LocationViewModel</code>:</p>

<pre><code class="language-java">    public class LocationViewModel extends ViewModel {
    
        private IssLocationRepository mRepository;
        private MutableLiveData&lt;IssLocationWrapper&gt; mIssLocation;
    
        public LocationViewModel() {
            super();
            mRepository = new IssLocationRepository();
            mIssLocation = mRepository.getLocation();
        }
    
        public MutableLiveData&lt;IssLocationWrapper&gt; getLocation() {
            return mIssLocation;
        }
    
        public void checkLocation() {
            mRepository.setLocation();
        }
    
    
    }
</code></pre>

<p>Nasz LocationViewModel jest w stanie zwrócić informację o lokalizacji ISS (<code>getLocation()</code>) oraz wysłać żądanie do repozytorium o ponowne ustalenie lokalizacji.</p>

<h3 id="ui-mainactivity">UI, MainActivity</h3>

<p>Jesteśmy gotowi by przekazać dane do warstwy UI. Przypomnijmy, że na layout <code>MainActivity</code> składają się TextView, w którym wyświetlać będziemy lokalizację ISS oraz Button do odświeżania lokalizacji.</p>

<p>MainActivity:</p>

<pre><code class="language-java">    public class MainActivity extends AppCompatActivity {
    
        private LocationViewModel mLocationViewModel;
        private TextView mLocationTextView;
        private Button mLocationCheckButton;
    
        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_main);
    
            mLocationTextView = findViewById(R.id.coordinates);
    
            mLocationViewModel = ViewModelProviders.of(this).get(LocationViewModel.class);
            mLocationViewModel.getLocation().observe(this, new Observer&lt;IssLocationWrapper&gt;() {
                        @Override
                        public void onChanged(@Nullable IssLocationWrapper issLocationWrapper) {
                            switch(issLocationWrapper.getResponseStatus()) {
                                case 1:
                                    mLocationTextView.setText(
                                        issLocationWrapper.getIssLocationJson().getIssPosition().getLatitude() + &quot; &quot;
                                                + issLocationWrapper.getIssLocationJson().getIssPosition().getLongitude());
                                    break;
                                case 0:
                                    mLocationTextView.setText(R.string.response_empty);
                                    break;
                                case -1:
                                    mLocationTextView.setText(R.string.response_failure);
                                    break;
                                default:
                                    mLocationTextView.setText(R.string.response_empty);
                                    break;
                            }
    
                        }
            });
    
            mLocationCheckButton = findViewById(R.id.checkButton);
            mLocationCheckButton.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    mLocationViewModel.checkLocation();
                }
            });
    
        }
    }
</code></pre>

<p>LocationViewModel dostarcza nam metoda <code>get()</code> <a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModelProvider"><code>ViewModelProvidera</code></a> (przypisanego do Activity), nie tworzymy ViewModeli ze &ldquo;zwykłego&rdquo; konstruktora.</p>

<p>Następnie zaczynamy obserwować (<code>observe()</code>) dane zwracane z ViewModel w metodzie <code>getLocation()</code>. Jeśli pamiętamy sprzed chwili, zwraca ona nam <code>MutableLiveData&lt;IssLocationWrapper&gt;</code>, a więc nasz obiekt z informacjami o lokalizacji ISS oraz stanem połączenia.</p>

<p>Jeśli dane te ulegną zmianie wywołana zostanie metoda<code>onChanged()</code> obserwatora. Sprawdzany jest status połączenia i stosownie uzupełniany TextView.</p>

<p>Pod koniec metody <code>onCreate()</code> mamy jeszcze zdefiniowany listener dla przycisku, obsługujący naciskanie przycisku przez użytkownika. Zauważmy, że nie wywołuje on już metody pobierającej dane z ViewModelu, a jedynie metodę aktualizacją lokalizację w samym LiveData w ViewModelu. Jako, że stan tego obiektu obserwujemy, to po zmianie jego zawartości automatycznie ujrzymy zmianę na poziomie UI w TextView.</p>

<h3 id="finisz">Finisz</h3>

<p>I to tyle, po odpaleniu aplikacji, zakładając dostęp do internetu, ujrzymy obrazek z początku artykułu:</p>

<p><img src="/images/oldblog/issfinishedappl.png" alt="image-center" />{: .align-center}</p>

<p>Jeśli zaś włączymy w emulatorze/telefonie tryb samolotowy, to ujrzymy:</p>

<p><img src="/images/oldblog/issfinishedapp.png" alt="image-center" />{: .align-center}</p>

<p>Podsumowując, zbudowaliśmy prostą aplikację, korzystającą z bibliotek Architecture Components oraz Retrofit. Warstwa UI jest odseparowana od reszty poprzez ViewModel. Wyświetlana informacja o lokalizacji ISS pochodzi z obserwowanego z poziomu UI obiektu LiveData przekazywanego przez ViewModel. ViewModel pozyskuje potrzebne informacje z Repository. W Repository wykonujemy połączenie z API przez Retrofit. UI nie wie, jak przetwarzane i skąd źródłowo pochodzą dane do wyświetlenia. ViewModel również na dobrą sprawę nie wie. Repository i ViewModel pozbawione są odwołań do klas związanych z UI. Warstwa UI natomiast pozbawiona jest odwołań do klas bezpośrednio związanych z logiką manipulacji i pozyskiwania danych.</p>

        </p>

        <div>
          <div class="post-back-link">
    <a href="javascript: history.back()">
        <i class="fa fa-arrow-left"></i> 
        Back
    </a>
</div>
        </div>
      </div>
    </div>
    

<footer>

</footer>

<script src="https://code.jquery.com/jquery-3.1.1.min.js"
  integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"
  integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<script src="/js/prism.js"></script>

</body>

</html>
