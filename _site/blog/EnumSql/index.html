<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.16.4 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>[OLD] Java 101: Enum + Servlets - Michał Wyrwa</title>
<meta name="description" content="[This is a post from my old website. Outdated packages and libraries. Viewer discretion is advised ;-)]">



<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Michał Wyrwa">
<meta property="og:title" content="[OLD] Java 101: Enum + Servlets">
<meta property="og:url" content="http://localhost:4000/blog/EnumSql/">


  <meta property="og:description" content="[This is a post from my old website. Outdated packages and libraries. Viewer discretion is advised ;-)]">







  <meta property="article:published_time" content="2017-07-06T17:02:00+02:00">






<link rel="canonical" href="http://localhost:4000/blog/EnumSql/">













<!-- end _includes/seo.html -->


<link href="/feed.xml"
  type="application/atom+xml" rel="alternate" title="Michał Wyrwa Feed">

<link href="https://fonts.googleapis.com/css?family=IBM+Plex+Serif&display=swap" rel="stylesheet">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">

<!--[if IE ]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->


    <!-- start custom head snippets -->

<link
    href="https://fonts.googleapis.com/css?family=Fjalla+One|Noto+Sans:400,400i,700,700i&display=swap&subset=latin-ext"
    rel="stylesheet">
<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->
  </head>

  <body class="layout--single">

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">Michał Wyrwa</a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/papers/" >Papers & Talks</a>
            </li><li class="masthead__menu-item">
              <a href="/teaching/" >Teaching Materials</a>
            </li><li class="masthead__menu-item">
              <a href="/about/" >About</a>
            </li><li class="masthead__menu-item">
              <a href="/posts/" >Posts</a>
            </li><li class="masthead__menu-item">
              <a href="/tags/" >Tags</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name"></h3>
    
    
      <p class="author__bio" itemprop="description">
        <h4>Office hours:</h4> <p></br> Mondays 11-14 </br> Tuesdays 11-12</p>
      </p>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      

      
        
          
            <li><a href="mailto:michal.wyrwa@amu.edu.pl" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i> Email</a></li>
          
        
          
            <li><a href="https://michalwyrwa.youcanbook.me" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Book me</a></li>
          
        
          
            <li><a href="https://orcid.org/0000-0003-4227-1629" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-link" aria-hidden="true"></i> ORCID</a></li>
          
        
          
            <li><a href="https://github.com/MiWy" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
          
        
          
            <li><a href="https://www.researchgate.net/profile/Michal_Wyrwa" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-researchgate" aria-hidden="true"></i> ResearchGate</a></li>
          
        
          
            <li><a href="https://scholar.google.com/citations?user=eJtcrykAAAAJ&hl=pl&authuser=1&oi=sra" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-google" aria-hidden="true"></i> Scholar</a></li>
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="[OLD] Java 101: Enum + Servlets">
    <meta itemprop="description" content="[This is a post from my old website. Outdated packages and libraries. Viewer discretion is advised ;-)]">
    <meta itemprop="datePublished" content="July 06, 2017">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">[OLD] Java 101: Enum + Servlets
</h1>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right ">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> Table of Contents</h4></header>
              <ul class="toc__menu">
  <li><a href="#enum">ENUM</a>
    <ul>
      <li><a href="#kiedy-stosować">Kiedy stosować?</a></li>
    </ul>
  </li>
  <li><a href="#prosta-aplikacja-webowa-servlets-tomcat">Prosta aplikacja webowa: Servlets, Tomcat</a>
    <ul>
      <li><a href="#przygotowania">Przygotowania*</a></li>
      <li><a href="#servlet-pobierający-informacje-z-bazy-danych">Servlet pobierający informacje z bazy danych</a></li>
    </ul>
  </li>
</ul>
            </nav>
          </aside>
        
        <p>[This is a post from my old website. Outdated packages and libraries. Viewer discretion is advised ;-)]</p>

<h2 id="enum">ENUM</h2>

<p>Typ <strong>enum</strong>, dodany w wersji 1.5, służy do definiowania stałych. Kiedy mamy z nim do czynienia, to wiemy że mamy do wyboru ograniczony zbiór możliwych opcji. Przykładowo, definiując enum <code class="highlighter-rouge">poraRoku</code> z góry wiemy, że będzie on przyjmować wartości jedynie spośród <em><code class="highlighter-rouge">ZIMA</code></em>, <em><code class="highlighter-rouge">WIOSNA</code></em>, <em><code class="highlighter-rouge">LATO</code></em> i <em><code class="highlighter-rouge">JESIEN</code></em>.</p>

<p>Każdy enum domyślnie rozszerza klasę <code class="highlighter-rouge">java.lang.Enum</code>, dlatego nie może rozszerzać żadnej innej klasy. Może natomiast implementować interfejsy. Enumy możemy definiować również jako klasy wewnętrzne.</p>

<p>Konstruktor może być <code class="highlighter-rouge">protected</code> (domyślnie) albo <code class="highlighter-rouge">private</code>. Nie przywołujemy go bezpośrednio. Weźmy nasz enum <code class="highlighter-rouge">poraRoku</code>:</p>

<pre><code class="language-Java">    class EnumCwiczenie {
      enum poraRoku {
        ZIMA, WIOSNA, LATO, JESIEN
      }

      public static void main(String[] args) {
        System.out.println(poraRoku.LATO + " to okres strasznej duchoty.");
      }
    }
</code></pre>

<p>Efekt: <code class="highlighter-rouge">LATO to okres strasznej duchoty.</code></p>

<p>Ciało klasy (<em>typu</em>) enum może zawierać metody i inne pola. Domyślnie w trakcie kompilacji dodawana jest metoda <code class="highlighter-rouge">values()</code>, zwracająca tablicę wszystkich wartości naszego enum w kolejności ich deklaracji w kodzie. Zobaczmy jak możemy zawrzeć więcej informacji w stałych enum:</p>

<pre><code class="language-Java">    class EnumCwiczenie {
      enum poraRoku {
        ZIMA("Gwiazdka"), WIOSNA("Wielkanoc"), LATO("Noc Kupaly"), JESIEN("Zaduszki");

        private final String waznaData;

        poraRoku(String waznaData) {
          this.waznaData = waznaData;
        }

        String getWaznaData() {
          return waznaData;
        }
      }

      public static void main(String[] args) {
        System.out.println(poraRoku.LATO + " to okres strasznej duchoty.");
        System.out.println("W trakcie tej pory roku ma miejsce " + poraRoku.LATO.getWaznaData() + ".");

        for(poraRoku pora : poraRoku.values()) {
          System.out.println("W trakcie pory " + pora + " ma miejsce " + pora.getWaznaData() + ".");
        }
      }
    }
</code></pre>

<p>Efekt:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    LATO to okres strasznej duchoty.
    W trakcie tej pory roku ma miejsce Noc Kupaly.
    W trakcie pory ZIMA ma miejsce Gwiazdka.
    W trakcie pory WIOSNA ma miejsce Wielkanoc.
    W trakcie pory LATO ma miejsce Noc Kupaly.
    W trakcie pory JESIEN ma miejsce Zaduszki.
</code></pre></div></div>

<p>Pełen zbiór domyślnych metod znaleźć można w <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Enum.html">dokumentacji</a>.</p>

<h3 id="kiedy-stosować">Kiedy stosować?</h3>

<p>Korzystając z enuma, mamy zagwarantowane istnienie tylko jednej instancji stałej (wygodny punkt wyjścia dla wzorca <a href="http://keaplogik.blogspot.com/2013/12/the-java-enum-singleton-pattern.html">Singleton</a>). Ponadto, możemy korzystać z operatora <code class="highlighter-rouge">==</code>. Zawarta w klasie <code class="highlighter-rouge">Enum</code> metoda <code class="highlighter-rouge">equals()</code> działa dokładnie tak samo jak ten operator, ale jest metodą, więc możemy otrzymać wyjątek <code class="highlighter-rouge">NullPointerException</code>, zamiast wartości <code class="highlighter-rouge">false</code> jak w przypadku porównania enum przy pomocy <code class="highlighter-rouge">==</code> z <code class="highlighter-rouge">null</code>.</p>

<p>Nie trzeba implementować interfejsu <code class="highlighter-rouge">Serializable</code> by móc serializować enumy. Ponadto, dokonując serializacji enuma, <em>de facto</em> serializowana jest jego nazwa, zwracana przez wbudowaną metodę <code class="highlighter-rouge">name()</code>, a przy deserializacji przywoływana jest metoda <code class="highlighter-rouge">valueOf()</code> naszego enuma, zwracająca stałą o tej nazwie. W ten sposób nie musimy serializować wartości wszytkich pól enuma.</p>

<p>Enumy pozwalają także na wygodniejsze stosowanie wyrażeń <code class="highlighter-rouge">switch</code>:</p>

<pre><code class="language-Java">    poraRoku jednaPoraRoku = poraRoku.WIOSNA;
    switch(jednaPoraRoku) {
      case LATO:
        System.out.println("Cieplo!");
        break;
      case ZIMA:
        System.out.println("Zimno!");
        break;
      case WIOSNA:
        System.out.println("W sam raz!");
        break;
      case JESIEN:
        System.out.println("Mokro!");
        break;
    }
</code></pre>

<p>Efekt: <code class="highlighter-rouge">W sam raz!</code></p>

<p>Nie zawsze stosowanie typu enum jest korzystne. Zajmują one więcej miejsca w pamięci (powód dla którego ich stosowanie <a href="https://developer.android.com/topic/performance/memory.html#Overhead">nie jest rekomendowane</a> przez zespół Androida). Jeżeli nasze stałe nie mają żadnych dodatkowych pól, to prawdopodobnie mniej zasobów będzie zajmować zwyczajowe <code class="highlighter-rouge">public static final</code>.
Z drugiej strony, enumy są łatwym sposobem obsługi stałych, które mają posiadać dodatkowe pola (a zatem więcej informacji) i własne metody.</p>

<p>Czyli, jak zawsze, stosować w sposób przemyślany ;).</p>

<h2 id="prosta-aplikacja-webowa-servlets-tomcat">Prosta aplikacja webowa: Servlets, Tomcat</h2>

<p>Mówiąc w skrócie, servlety to klasy pomagające serwerowi w odpowiadaniu na żądania ze strony klienta. Jako że najczęściej żądania są w protokole HTTP, to pisząc servlet zwykle rozszerzamy klasę <code class="highlighter-rouge">javax.servlet.http.HttpServlet</code>, i nie bawimy się w implementację samego interfejsu <code class="highlighter-rouge">javax.servlet.Servlet</code>.</p>

<p>Zwróćcie uwagę na początek tych nazw: java<strong>x</strong>, nie zwykłe java. Standardowa edycja Javy nie zawiera servletów, Jeżeli używaliście wcześniej platformy Javy SE, to będziecie musieli ściągnąć brakujące biblioteki, albo po prostu przerzucić się na Javę EE, która je (i inne) zawiera. Przykładowo, jeśli korzystacie z Eclipse’a, macie do wyboru <a href="https://www.eclipse.org/ide/">kilka wersji</a> programu. Zainstalujcie <a href="https://www.eclipse.org/downloads/packages/eclipse-ide-java-ee-developers/oxygenr">wersję dla Javy EE </a>i będziecie mieć spokój ;).</p>

<p>Potrzebny jest też serwer oraz (akurat dla potrzeb takich servletów, jakie napiszemy) baza danych. W poniższych przykładach wykorzystany jest <a href="http://tomcat.apache.org">Tomcat</a> oraz <a href="https://www.mysql.com">MySQL</a>. Nie będziemy krok po kroku przerabiać ich instalacji, w internecie bez problemu można znaleźć instrukcje do każdego systemu operacyjnego. Za pierwszym razem może to trochę czasu zająć, szczególnie jeśli się nie miało wcześniej do czynienia z linią komend, ale warto tę chwilę poświęcić. Założenie jest zatem takie, że Tomcat jest zainstalowany, a na dysku utworzona została baza danych MySQL.</p>

<p><code class="highlighter-rouge">javax.servlet.http.HttpServlet</code> zawiera <a href="http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServlet.html">szereg metod</a> odpowiadającym żądaniom HTTP. Skorzystamy z metod <code class="highlighter-rouge">doGet()</code> oraz <code class="highlighter-rouge">doPost()</code>. Różnica pomiędzy GET a POST polega na widoczności przesyłanych danych. Żądanie GET zawiera przesyłane do serwera informacje w adresie URL (można więc podejrzeć je nawet w historii przeglądarki), stąd dane muszą być zapisane za pomocą znaków ASCII. Przeglądarki i serwery nakładają ograniczenia na maksymalną długość adresu URL (od 2048 w górę), więc i z tej perspektywy jesteśmy ograniczeni. Dla żądania POST format danych nie jest tak istotny.</p>

<p>Napiszemy bardzo prostą aplikację webową: pamiętnik operujący na lokalnym serwerze.</p>

<h3 id="przygotowania">Przygotowania*</h3>

<p>(*Eclipse, wszystko można zrobić bez pomocy IDE)</p>

<p>Potrzebny jest nam nowy projekt, skonfigurowany do działania na serwerze. W Eclipse klikamy <strong>File </strong>-&gt; <strong>New </strong>-&gt; <strong>Dynamic Web Project</strong>. Po podaniu nazwy projektu, obok pola <em>Target runtime</em> klikamy przycisk <em>New Runtime…</em>, wybieramy wersję Tomcata, klikamy <em>Finish</em>. Kreator projektu również zamykamy klikając <em>Finish</em>. Ok, mamy lokalny serwer, na którym będziemy odpalać nasze servlety.</p>

<p>Teraz baza danych. Upewnij się, że masz włączony domyślną perspektywę w Eclipse (<em>Window </em>-&gt; <em>Perspective</em> -&gt; <em>Open perspective</em> -&gt; <em>Java EE</em>). U dołu okna IDE kliknij w <em>Data Source Explorer</em> i prawym przycikiem myszy na <em>Database Connections</em>. Kliknij <em>New</em>, z listy wybierz MySQL. Po naciśnięciu <em>Next</em> wpisz dane do swojej bazy danych (nazwa pod polem <em>Database</em>, pełen URL, login i hasło). Jeżeli po naciśnięciu <em>Test Connection</em> pokazuje się komunikat o niepowodzeniu, sprawdź wybrany sterownik. W naszym wypadku jest to JDBC Driver, ściągnąć go można <a href="https://www.mysql.com/products/connector/">tutaj.</a> a zmienić naciskając na ikonę trójkąta po prawej strony od listy sterowników, wskazując na miejsce, gdzie tenże .jar znajduje się na dysku.</p>

<p><img src="/assets/images/oldblog/20-07_servlet_databasedriver.png" alt="image-center" class="align-center" /></p>

<p>W naszym wypadku baza danych nazywa się <code class="highlighter-rouge">diary</code>, a przygotowana wcześniej tabela <code class="highlighter-rouge">ENTRIES</code>, z następującymi kolumnami:</p>

<pre><code class="language-SQL">    CREATE TABLE ENTRIES(
        id INT NOT NULL AUTO_INCREMENT,
        title VARCHAR(200),
        date DATETIME,
        content LONGTEXT,
        PRIMARY KEY ( id )
    );
</code></pre>

<h3 id="servlet-pobierający-informacje-z-bazy-danych">Servlet pobierający informacje z bazy danych</h3>

<p>Tak jak wyżej napisano, servlety służące do obsługi żądań HTTP powinny rozszerzać klasę <code class="highlighter-rouge">javax.servlet.http.HttpServlet</code>. A więc:</p>

<pre><code class="language-Java">    @WebServlet("/DiaryArchive")
    public class DiaryArchive extends HttpServlet {
    }
</code></pre>

<p>Kilka słów o <a href="http://docs.oracle.com/javaee/7/api/javax/servlet/annotation/WebServlet.html"><code class="highlighter-rouge">@WebServlet</code></a>. Pojawiła się ona w specyfikacji <a href="http://download.oracle.com/otn-pub/jcp/servlet-3.0-fr-eval-oth-JSpec/servlet-3_0-final-spec.pdf?AuthParam=1500537336_edf2e70ab23c230015d7612efce60f3d">Servlet 3.0</a>. Wcześniej dla każdej aplikacji sieciowej obsługiwanej przy pomocy servletów należało tworzyć deskryptor w pliku <code class="highlighter-rouge">web.xml</code>, w którym m.in. umieszczaliśmy informacje na temat wszystkich servletów. Dzięki temu kontener servletów (w naszym przypadku Tomcat) wiedział, który servlet powinien odpalić na dany typ żądania ze strony klienta. Adnotacja <code class="highlighter-rouge">@WebServlet</code> ułatwia nam pracę, takowego pliku przygotowywać nie trzeba (Tomcat ją obsługuje od wersji 7.0).</p>

<p>W dokumentacji wymieniony jest szereg atrybutów adnotacji, ale podawać trzeba jedynie <code class="highlighter-rouge">urlPatterns</code>/<code class="highlighter-rouge">value</code>, wskazując URL pod którym nasz servlet będzie aktywny.</p>

<p>Nasz pierwszy servlet będzie służyć do odczytywania z bazy danych wpisów z pamiętnika. Żadnych specjalnych danych do serwera nie przesyłamy, tylko żądanie wyświetlenia wpisów, więc skorzystamy z żądania GET, a więc przesłaniamy metodę <code class="highlighter-rouge">doGet()</code>. Od razu ustalimy typ odpowiedzi (będzie to wyświetlany w przeglądarce html) oraz przygotujemy przypiszemy zmienną <strong>out</strong> do obiektu <code class="highlighter-rouge">PrintWriter</code> wziętego z <code class="highlighter-rouge">HttpServletResponse</code>. Ten posłuży nam do przesłania tekstu (kodu html) do klienta:</p>

<pre><code class="language-Java">    protected void doGet(HttpServletRequest request, HttpServletResponse response) 
          throws ServletException, IOException {
                    response.setContentType("text/html");
                    PrintWriter out = response.getWriter();
    }
</code></pre>

<p>Czas na małe parsowanie. Najpierw część kodu html, do którego nie potrzebujemy informacji z bazy danych:</p>

<pre><code class="language-Java">    String title = "My Db Diary";
    String docType =  "&lt;!DOCTYPE html&gt;\n";

    out.println(docType + 
        "&lt;html&gt;\n" +
        "&lt;head&gt;&lt;title&gt;" + title + "&lt;/title&gt;&lt;/header&gt;\n" +
        "&lt;body bgcolor = \"#f3f3f3\"&gt;\n" +
        "&lt;h1 align = \"center\"&gt;" + title + "&lt;/h1&gt;\n" +
        "&lt;h3 align = \"center\"&gt;&lt;a href=\"http://localhost:8080/DiaryServlet/DiaryMain.html\"&gt;Add new entry&lt;/a&gt;&lt;/h3&gt;");
</code></pre>

<p>Od razu zawarliśmy w nim URL, pod którym będzie działać nasz drugi servlet. Na razie wejście pod ten adres wywołałoby jedynie błędy.</p>

<p>Pozostaje nam połączenie się z bazą danych, pobranie wpisów i sparsowanie ich do kodu HTML. Najpierw kilka stałych:</p>

<pre><code class="language-Java">    private static final String JDBC_DRIVER = "com.mysql.jdbc.Driver";
    private static final String DB_URL = "jdbc:mysql://localhost:3306/diary";  // Adres naszej bazy MySQL
    private static final String USER = "root"; // Login do bazy
    private static final String PASS = "root"; // Hasło do bazy

    try {	
      // Rejestrujemy sterownik.
      Class.forName(JDBC_DRIVER);

            // Podłączamy się do naszej bazy MySQL
      Connection con = DriverManager.getConnection(DB_URL, USER, PASS);

            // Przygotowujemy zapytanie do bazy oraz obiekt klasy ResultSet z danymi zwrotnymi.
      Statement stmt = con.createStatement();
      String sql = "SELECT id, date, title, content FROM ENTRIES";
      ResultSet rs = stmt.executeQuery(sql);

            // Parsujemy każdy kolejny wiersz pobrany do obiektu ResultSet do kodu HTML.
      while(rs.next()) {
        int id = rs.getInt("id");
        Timestamp ts = rs.getTimestamp("date");
        String entryTitle = rs.getString("title");
        String entryContent = rs.getString("content");

        out.println("&lt;h3 align = \"center\"&gt;" + id + ": " + ts.toString() + "&lt;/h3&gt;");
        out.println("&lt;h2 align = \"center\"&gt;" + entryTitle + "&lt;/h2&gt;&lt;br&gt;");
        out.println(entryContent + "&lt;br&gt;");
      }
      out.println("&lt;/body&gt;&lt;/html&gt;");
      
            // Zamykamy połączenia z bazą danych (dla przejrzystości przykładu zakładamy, że nie wystąpią w tym miejscu wyjątki).	
      rs.close();
      stmt.close();
      con.close();
    } catch(SQLException se) {
      se.printStackTrace();
    } catch(Exception e) {
      e.printStackTrace();
    }
</code></pre>

<p>Pierwszy servlet gotowy. Gdy klikniemy <em>Run</em> -&gt; <em>Run as…</em> -&gt; <em>Run on Server</em> powinniśmy ujrzeć coś takiego:</p>

<p><img src="/assets/images/oldblog/20-07servlet_effect1.png" alt="image-center" class="align-center" /></p>

<p>Zwróćcie uwagę, że adres URL to połączony adres bazy danych oraz adresu podanego w adnotacji <code class="highlighter-rouge">@WebServlet</code>.</p>

<p>Czas na drugi servlet, pozwalający na dodawanie nowych wpisów do bazy. Jak widać podany adres servleta nie musi pokrywać się z nazwą klasy:</p>

<pre><code class="language-Java">    @WebServlet("/DiaryNew")
    public class UploadEntryServlet extends HttpServlet {
            private static final String JDBC_DRIVER = "com.mysql.jdbc.Driver";
            private static final String DB_URL = "jdbc:mysql://localhost:3306/diary";
            private static final String USER = "root";
            private static final String PASS = "root";
    }
</code></pre>

<p>Tym razem skorzystamy z żądania POST, bo inaczej cała treść wpisu w żądaniu GET musiałaby wejść w adres URL. Przesłaniamy metodę <code class="highlighter-rouge">doPost()</code>:</p>

<pre><code class="language-Java">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // Tym razem pobieramy informacje z obiektu HttpServletRequest 
        String entryTitle = request.getParameter("title");
        String content = request.getParameter("entry");
        // Jedna z kolumn w bazie jest typu DATETIME, potrzebujemy więc obiektu Timestamp z aktualną datą.
        Timestamp timestamp = new Timestamp(System.currentTimeMillis());
        
        try {
          Class.forName(JDBC_DRIVER);
          
          Connection con = DriverManager.getConnection(DB_URL, USER, PASS);
          
          // Przygotowujemy dane do wysłania do bazy.
          String sql = "INSERT INTO ENTRIES (content, date, title) values (?, ?, ?)";
          PreparedStatement statement = con.prepareStatement(sql);
          statement.setString(1, content);
          statement.setString(3,  entryTitle);
          statement.setTimestamp(2, timestamp);
          
          // Wysyłamy przygotowane dane do bazy i zamykamy połączenia.
          statement.executeUpdate();
          statement.close();
          con.close();
        } catch(SQLException se) {
          se.printStackTrace();
        } catch(Exception e) {
          e.printStackTrace();
        }
        // Po wysłaniu wpisu do bazy, przejdź pod URL pierwszego servleta i pokaż zawartość pamiętnika 
        response.sendRedirect("DiaryArchive");
      }
</code></pre>

<p>Gdybyśmy spróbowali odpalić ten servlet na serwerze, wyskoczy nam błąd 405. Nie wysłaliśmy bowiem żądania POST, więc sprawdzane jest (po adresie URL) żądanie GET, a tego nasz servlet nie obsługuje. Musimy przygotować plik .html do obsługi naszego servleta. Umieścimy go w projekcie w folderze <em>WebContent</em>/<em>WEB-INF</em>:</p>

<p><img src="/assets/images/oldblog/20-07servlet_htmlplace.png" alt="image-center" class="align-center" /></p>

<p>Przesyłane są informacje zawarte pomiędzy znacznikami <code class="highlighter-rouge">&lt;form&gt;</code> i <code class="highlighter-rouge">&lt;/form&gt;</code>, odzyskiwane w kodzie servleta poprzez atrybut <code class="highlighter-rouge">name</code>:</p>

<pre><code class="language-HTML">    &lt;!DOCTYPE html&gt;
    &lt;html&gt;
    &lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;My Db Diary&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;h3 align="center"&gt;Read your diary: &lt;a href="http://localhost:8080/DiaryServlet/DiaryArchive"&gt;HERE&lt;/a&gt;&lt;/h3&gt;
    &lt;h3&gt;New Entry:&lt;/h3&gt;
          &lt;form action = "DiaryNew" method = "post"&gt;
             Title: &lt;input type = "text" name = "title"/&gt; &lt;br/&gt;
             Entry: &lt;br/&gt; &lt;textarea rows="20" cols="90" wrap="hard" id="entryfield" name="entry"&gt;&lt;/textarea&gt; &lt;br/&gt;
             &lt;input type="submit" value="Submit"/&gt;
          &lt;/form&gt;
    &lt;/body&gt;
    &lt;/html&gt;
</code></pre>

<p>Po odpaleniu zobaczymy coś takiego:</p>

<p><img src="/assets/images/oldblog/20-07servlet_effect2.png" alt="image-center" class="align-center" /></p>

<p>I to tyle! Mamy prosty (prostacki ;)) pamiętnik przetrzymywany w bazie danych, z którym łączymy się Javą poprzez serwer lokalny. Póki nie wyłączymy serwera ani bazy danych możemy łączyć się z pamiętnikiem przez dowolną przeglądarkę.</p>

<p>Pełen kod dostępny na <a href="https://github.com/MiWy/doksaprosta_blog_code_snippets/tree/master/Java101/20-07_servlets">GitHubie</a>.</p>

        
      </section>

      <footer class="page__meta">
        
        
  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/tags/#coding" class="page__taxonomy-item" rel="tag">coding</a>
    
    </span>
  </p>




  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/categories/#blog" class="page__taxonomy-item" rel="tag">blog</a>
    
    </span>
  </p>


        
          <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2017-07-06T17:02:00+02:00">July 06, 2017</time></p>
        
      </footer>

      

      
  <nav class="pagination">
    
      <a href="/blog/android_courier_firebase/" class="pagination--pager" title="[OLD] Courier App for Android
">Previous</a>
    
    
      <a href="/blog/SpotiBar/" class="pagination--pager" title="[OLD] SpotiBar: Spotify + Foobar
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><input type="search" id="search" aria-placeholder="Enter your search term..." class="search-input" tabindex="-1" placeholder="Enter your search term..." />
    <div id="results" class="results"></div></div>

      </div>
    

    <div class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    

    <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2019 Michał Wyrwa. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>
  <script defer src="https://use.fontawesome.com/releases/v5.8.2/js/all.js" integrity="sha384-DJ25uNYET2XCl5ZF++U8eNxPWqcKohUUBUpKGlNLMchM7q4Wjg2CUpjHLaL8yYPH" crossorigin="anonymous"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>







  </body>
</html>
